음수를 표현하기 위해 사용

### 1의 보수
> 어떤 2진수를 0->1, 1->0으로 바꿔서 얻는 수
ex) 0010 0100 -> 1101 1011


최초의 컴퓨터에서 음수 표현을 1의 보수로 표현
(7비트만 사용, MSB, 음수 표현을 위해)

0이 두개 생기는 문제가 발생
+0 : 0000 0000
-0 : 1111 1111

그래서 2의 보수가 탄생


### 2의 보수
> 1의 보수에서 +1을 한 값
ex) 0010 0100 -> 1101 1011 (1의 보수) > 1101 1100 (2의 보수)

1Byte 의 표현 범위 : -128 ~ 127



컴퓨터가 2진수를 사용하는 이유
  1. 하드웨어적인 이유
        IC(직접회로) 0v 또는 5V중 하나의 전압을 가짐.
        그렇기 때문에 핀1개로는 2개의 상태만 표현 가능




실수 표현 방식

1. 고정 소수점
실수는 정수부와 소수부로 나눌 수 있음
소수부 자릿수를 정해 놓고, 고정된 자리수로 소수를 표현하는 것
1bit(부호) + 15bit(정수부) + 16비트(소수부)

정수부와 소수부 자리가 크지 않아 표현 범위가 적다는 단점이 존재

2. 부동 소수점
실수를 정수부, 소수부가 아닌 가수부와 지수부로 나누어 표현하는 ㅂ아식

+-(1.가수부) * 2^(지수부 -127)

IEEE 부동 소수점 방식 (IEEE 754)
ex) 32bit float
1bit(부호) + 8bit(가수부) + 23bit(지수부)
ex) 32bit double
1bit(부호) + 11bit(가수부) + 52bit(지수부)

부호부 0-양수, 1-음수
지수부 - 지수부를 표현 float의 경우 (2^8승) -1 까지 표현 가능
컴퓨터가 일반적으로 표현하는 방식과 다름.
bias 표현 법이라 불림.
일반적으로는
0111 1111 : 127
1000 0000 : -128
1000 0001 : -127
이런식으로 표현하지만
bias는
0000 0000 : -127
0000 0001 : -126
0111 1111 : 0
1111 1111 : 128
이런식으로 표현

이유는 정수 표현할때와 지수표현할때 0과 음수의 의미가 다르기 때문
(밑이 양수라면 지수가 음수여도 0 이상이 됨. 0에가까워지는 수)



bias 상수 : 2^(n-1) - 1
N은 비트부 자리수 (32bit에서는 8bit)

2의 보수법 + 바이어스 상수 = 바이어스 표현법
(32bit에서 2의 보수법을 바이어스 표현법으로 바꾸려면 127을 더하면 됨)



가수부 - 가수부의 수의 모양을 알려줌 앞에서부터 채움.


고정 소수점 방식보다 훨씬 더 많은 범위까지 표현이 가능하지만
오차가 존재한다는 단점도 존재
(*컴퓨터에서 표현하는 실수는 정확한 표현이 아닌 근사치 표현임, 모든 프로그래밍 언어에서 발생하는 기본적인 문제)


부동 소수점에서의 0표현
= 모든 비트가 0
<0 표현 법은 다시 한번 공부해야함>



오차가 생기는 이유는 가수부 표현범위가 정해져잇기 때문
32bit 기준 가수부는 23bit 하지만 실제 값 자리수가 23자리를 넘어가면 오차가 발생하게됨.
